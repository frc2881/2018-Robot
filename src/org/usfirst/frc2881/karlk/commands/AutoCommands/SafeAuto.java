// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc2881.karlk.commands.AutoCommands;

import edu.wpi.first.wpilibj.command.ConditionalCommand;
import org.usfirst.frc2881.karlk.commands.AutoCommands.AutoCrossLineCommands.AutoCrossLineCommand;
import org.usfirst.frc2881.karlk.commands.AutoCommands.AutoScaleCommands.AutoScaleCommand;
import org.usfirst.frc2881.karlk.commands.AutoCommands.AutoSwitchCommands.AutoSwitchCommand;
import org.usfirst.frc2881.karlk.commands.AutoCommands.Enums.AutoOptions;
import org.usfirst.frc2881.karlk.commands.AutoCommands.Enums.AutoStrategy;
import org.usfirst.frc2881.karlk.commands.AutoCommands.Enums.StartingLocation;
import org.usfirst.frc2881.karlk.commands.AutoCommands.Enums.SwitchPosition;
import org.usfirst.frc2881.karlk.commands.DriveForward;

/**
 *
 */
class SafeAuto extends AbstractAutoCommand {

    SafeAuto(StartingLocation start, AutoOptions auto,
             SwitchPosition side, String gameData, AutoStrategy strategy) {

        if (auto == AutoOptions.NONE) {
            return;
        }

        boolean switchOnLeft = gameData.charAt(0) == 'L';
        boolean switchOnRight = !switchOnLeft;

        boolean scaleOnLeft = gameData.charAt(1) == 'L';
        boolean scaleOnRight = !scaleOnLeft;

        boolean canGoLeft = start == StartingLocation.LEFT || (start == StartingLocation.CENTER && strategy == AutoStrategy.SAFE_AUTO_LEFT);
        boolean canGoRight = start == StartingLocation.RIGHT || (start == StartingLocation.CENTER && strategy == AutoStrategy.SAFE_AUTO_RIGHT);

        boolean scoreSwitch = auto == AutoOptions.SWITCH && ((canGoLeft && switchOnLeft) || (canGoRight && switchOnRight));

        boolean scoreScaleLeft = auto == AutoOptions.SCALE && canGoLeft && scaleOnLeft;
        boolean scoreScaleRight = auto == AutoOptions.SCALE && canGoRight && scaleOnRight;

        boolean scoreBothRight = auto == AutoOptions.BOTH && canGoRight && switchOnRight && scaleOnRight;
        boolean scoreJustScaleRight = auto == AutoOptions.BOTH && canGoRight && scaleOnRight && switchOnLeft;
        boolean scoreJustSwitchRight = auto == AutoOptions.BOTH && canGoRight && scaleOnLeft && switchOnRight;

        boolean scoreBothLeft = auto == AutoOptions.BOTH && canGoLeft && switchOnLeft && scaleOnLeft;
        boolean scoreJustScaleLeft = auto == AutoOptions.BOTH && canGoLeft && scaleOnLeft && switchOnRight;
        boolean scoreJustSwitchLeft = auto == AutoOptions.BOTH && canGoLeft && scaleOnRight && switchOnLeft;

        // Move away from the wall
        addSequential(new DriveForward((46.0 - 17.8) / 12));

        if (scoreSwitch || scoreJustSwitchRight || scoreJustSwitchLeft) {
            addSequential(new AutoSwitchCommand(start, gameData, side, strategy));

        } else if (scoreBothRight || scoreScaleRight || scoreBothLeft || scoreScaleLeft) {
            addSequential(new AutoScaleCommand(start, gameData, auto, side, strategy));

        } else if (scoreJustScaleRight || scoreJustScaleLeft) {
            addSequential(new AutoScaleCommand(start, gameData, AutoOptions.SCALE, side, strategy));

        } else {
            addSequential(new AutoCrossLineCommand(start, strategy));
        }
    }

}
